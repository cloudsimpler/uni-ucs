type tempType = {
	type : string;
	obj : UTSJSONObject;
	string : string;
	number : number;
	array : any[]
}

export function getDeepProperty(obj : any, path : string) : any {
	// 将路径字符串分割成数组
	const keys = path.split('.');
	let temp : tempType = {
		type: "string",
		obj: {},
		string: "",
		number: 0,
		array: []
	};

	try {
		temp.obj = obj as UTSJSONObject
	} catch (e) {
		temp.array = obj as any[]
	};

	keys.forEach(element => {
		const type = typeof temp.obj[element];

		if (type == "object") {
			/**
			 * 因为array在typeof识别类型为object
			 * 所以同时在这里进行处理，array类型在异常处理中赋值
			 */
			try {
				if (element.indexOf("[") != -1 && element.indexOf("]") != -1) {
					const str = element.replace("[", "").replace("]", "")
					temp.obj = temp.array[parseFloat(str)] as UTSJSONObject;
				} else {
					temp.obj = temp.obj[element] as UTSJSONObject;
				};
				temp.type = "obj";
			} catch (e) {
				temp.array = temp.obj[element] as any[];
				temp.type = "array";
			};
		} else if (type == "string") {
			temp.string = temp.obj[element] as string;
			temp.type = "string";
		} else if (type == "Int" || type == "Double" || type == "number") {
			temp.number = temp.obj[element] as number;
			temp.type = "number";
		} else {
			console.error(`当前参数属性类型为：${type}未进行适配，请联系作者进行适配`);
		};
	});

	return temp[temp.type] as any
}